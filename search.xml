<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2024年终总结丨Don&#39;t Look Back In Anger</title>
      <link href="/2024/12/17/Don%E2%80%98t%20look%20back%20in%20anger%E4%B8%A8%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>/2024/12/17/Don%E2%80%98t%20look%20back%20in%20anger%E4%B8%A8%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=4226232&auto=0&height=66"></iframe><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>这一年总算是过去了，写一篇来记录和总结一下自己。这一年的最大的主题是高考，大人们经常说这么一句话，你就抱着你那《五年高考三年模拟》偷着乐吧，等你工作就知道读书有多爽了，这一点我部分赞同，因为高三下期排除在外。</p><p>今年是值得记录的一年，就码一点字。</p><span id="more"></span><p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/2024%E6%80%BB%E7%BB%93/zoulang.jpg"></p><h1 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h1><p>在整个六月之前，我的主线任务一直围绕着<strong>高考</strong>而展开。在200天倒计时开始的时候，我觉得这日子是如此的难熬，时间流动的太慢了。换回现在大学的视角来看，之前的我确实是有挺多的想法的，才能让时间过得这么慢。不好好学习的后果就是真要到考试了是真的很慌张。我脑补了N种可能的情况，但结果确实最好的那一个，现在觉得当时精力确实很在线，试卷都那么多了还有时间瞎想。</p><p>倒数50天左右每天都要写很多张试卷，那时候的感知就没有那么强烈了，因为拿到题目就只能写了，没有太多东西可以考虑了。氛围有点压抑，一切发展的也挺有序，闲下来我总是在空想着考完干点什么。</p><p>高考那天，我穿着一双拖鞋就直接去了考场，樊姐问 “穿着拖鞋去高考啊？” 第一场过于紧张所以语文答的很糟糕，但命运在物理考试时眷顾了我，硬生生的给我估的分数高了20，我已经很满意了。出分那一天刚好在体育馆碰到物理老师牛Mer，我就觉得可能有些说法。</p><p>我报了一个离家近的学校，选专业上听了YanBo的建议，现在的我还是很满意的。</p><h1 id="后悔买晚了"><a href="#后悔买晚了" class="headerlink" title="后悔买晚了"></a>后悔买晚了</h1><ul><li>MUJI的双肩包，带行李箱带子，背袋</li></ul><p>​拿东西特方便，直接往后手一伸拉链一拉</p><ul><li>降噪耳机</li></ul><p>​第一次用的时候直接被震撼到了，一键静音</p><ul><li>2K高刷显示屏</li></ul><p>​24寸完全够我用了，不要太舒服</p><p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/2024%E6%80%BB%E7%BB%93/backpack.jpg"></p><h1 id="年度食物"><a href="#年度食物" class="headerlink" title="年度食物"></a>年度食物</h1><p>上半年全部在食堂，我们学校能选的品很少。让我忘记不了的就只有两个，一个是早上的汤粉和晚上的面条。</p><p>我每天早上都比较饿，所以我都会在早读前早早准备好，系系鞋带啥的，铃声一响就直接小跑到食堂。</p><p>先说粉，上半年我还没有搞清楚这粉怎么吃，一次偶然打粉的叔往我碗里加了点辣椒炒肉的汤汁，我才真真意识到我前几年错过什么了。真是太香了，现在我还在怀念那一口鲜香又微辣的味道，唤醒我的一天，辣椒炒肉码子粉是这个👍。</p><p>面，一般是不知道吃什么的时候吃的。学校的面在吃法上有个特色就是不能加汤。这是第一个关键，但是也不知道学校为什么不卖拌面，每次想吃都要说一声“炸酱汤面不加汤”。这个炸酱是第二个关键（虽然炸酱似乎没什么酱）。饿的时候来这一碗碳水炸弹十分享受，吃的次数太多了，现在味道还是能回忆起来。</p><p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/2024%E6%80%BB%E7%BB%93/miantiao.jpg"></p><p>下半年出去吃的话，吃的最多的就是麦当劳。又不是哪天灵机一动想起来用闲鱼点单能省一两块钱，我就感觉赚了一个亿。有一周连续七天连续吃一餐，最爱板烧打折只要9块。我心里麦当劳是快餐品类的第一。</p><p>食堂吃的最多就是饺子。吃饺子大多时候在早上，早上没胃口，只有蘸醋的饺子才能让我开开胃。然后口味很多，我的排名：大葱＞玉米＞韭菜＞包菜。</p><h1 id="今年过的咋样"><a href="#今年过的咋样" class="headerlink" title="今年过的咋样"></a>今年过的咋样</h1><p>今年上半年很累，下半年很爽。</p><p>累是肯定的，特别是在那么紧张的环境里边我特容易多想，现在的我，回过去看过去一些想法，有许多是很多余的，带给了自己许多压力。我记得，有段时间特别沮丧，沮丧到我感觉我这辈子都没有这么沮丧过。有个发现就是特别难过的时候我话就特别少，不想和别人交流，然后猛吃零食。</p><p>这一年发生了许多的好事和坏事，坏事不能说是坏事因为至少让我能成长一点，以前的我总是找借口逃避问题，现在我大概七成问题都会想着去解决，这是我觉得今年我最大的变化了。</p><p>上大学意味着由紧张到FREE的氛围，想吃喝玩乐就能立马去。认识了新的朋友，十分开心。但还是没有完全适应这个非常FREE的氛围，到现在这个时间，我感觉已经有点腻了，so希望马上能够专注自己的目标吧。</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>去年没有立什么Flag，今年开始立吧，希望明年这时候这些都能完成好。</p><ul><li><p>在暑假的时候我就一直考虑将来学些什么，思来想去还是选择了转码这条路径。25年先学习好CPP吧，多了解一下程序设计的流程。</p></li><li><p>学好英语，英语互联网还是很有意思的，希望能学好英语以后好出去玩。</p></li><li><p>然后就是web3，区块链这个概念很有意思，而且最近几年也越来越火了。眼睁睁看着大饼从7万到今天的10.6万。</p></li><li><p>戒烟，还TM是戒烟。</p></li><li><p>坚持把这个网站更新下去，毕竟一年的域名也便宜，到年底了又要续费了。希望十年后希望这个小站还在这互联网上。</p></li><li><p>？？？。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>「周结#3」谁说这天气烂的啊，这天气太棒了。</title>
      <link href="/2024/11/13/weekly-review2024-11-13/"/>
      <url>/2024/11/13/weekly-review2024-11-13/</url>
      
        <content type="html"><![CDATA[<p><img src="http://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E5%91%A8%E8%AE%B0/3/banner3.png"></p><blockquote><p>背光拍下来的的花🌸</p></blockquote><span id="more"></span><h1 id="校运动会，出门踏秋"><a href="#校运动会，出门踏秋" class="headerlink" title="校运动会，出门踏秋"></a>校运动会，出门踏秋</h1><p>因本人懒，故只能以观众的身份参加这次的运动会。一场一场的比赛就我而言有点枯燥了，所以就趁着这喜人的天气☀️出去探索一番。</p><p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E5%91%A8%E8%AE%B0/3/zj%20(1).jpg"></p><p>之前刷到过本地有国军立着的纪念碑🪦，所以和朋友约好了一起去看看。到了还挺吃惊的，这个地方完美的融入的街道。开始我以为有一个单独的公园，没想到就在街道边上。</p><blockquote><p>常德会战纪念碑位于中国湖南省常德市，建于纪念1943年发生的常德会战。这场战役是抗日战争期间中国军队与日军进行的一次激烈战斗，目的是阻止日军在湖南地区的进攻。常德会战中，中国守军奋力抵抗，以伤亡惨重为代价击退日军，成功守住了常德。纪念碑象征着对战斗中牺牲的中国军民的追思与敬意，同时提醒人们铭记抗战历史，不忘英勇先烈的牺牲精神。<strong>BY Chatgpt</strong></p></blockquote><p>街边有个特别大的牌坊，中间镶着国军前天白日军徽，相当霸气。整条街道绿化的非常好，纪念碑藏在里头，整条街上种满了梧桐树，太阳照下来很好看。</p><p><img src="http://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E5%91%A8%E8%AE%B0/3/zj%20(3).jpg"></p><p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E5%91%A8%E8%AE%B0/3/zj%20(5).jpg">然后一路转到常德诗墙，这儿靠着一条江，有人游泳，有人散步，悠闲退休的气氛环绕在这儿，最开心的还是拿着退休金的大爷大妈。整个诗墙在一个水坝上，上面刻满了诗，绕着一个圆弧形的坝，无奈文化造诣有限，没有细细欣赏下来。</p><p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E5%91%A8%E8%AE%B0/3/zj%20(8).jpg"></p><p>接着饱餐一顿搞到下一站，常德市博物馆。这里没有多少人，整个博物馆也是那种标准的布局，从石器时代到现代。一路下来感叹了老祖宗的智慧，许许多多的小玩意都十分精致。说到这就有点遗憾没有预约到国博的门票😭。近代区的主题就比较沉重了，常德会战，常德细菌战。</p><p><img src="http://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E5%91%A8%E8%AE%B0/3/zj%20(9).jpg"></p><blockquote><p>发财,发财,还是发财💴</p></blockquote><h1 id="上课现状"><a href="#上课现状" class="headerlink" title="上课现状"></a>上课现状</h1><p>现在这个课上的我真的很迷糊啊，专业课听不懂，基础课不想听。高数确实是一道坎，虽然才大一，但已经被压力到了。</p><p>大一的公共基础课真的是太烦了，我实在想不出思政，军事理论，职业规划..这些有什么用。</p><p>真正的学习还得是在互联网。</p><h1 id="自律？"><a href="#自律？" class="headerlink" title="自律？"></a>自律？</h1><p>最近日子过得还比较讲究。</p><p>首先3KM就跑了很多回，脸瘦了不少，这应该是最直观的好处了。每天睡的不错，继续保持！</p>]]></content>
      
      
      <categories>
          
          <category> 每周回顾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>「周结#2」希望每天都能睡好</title>
      <link href="/2024/11/06/weekly-review2024-11-6/"/>
      <url>/2024/11/06/weekly-review2024-11-6/</url>
      
        <content type="html"><![CDATA[<p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/yublog-image/image/2024/all/weekly-banner2.png"></p><blockquote><p>出门上自习时候拍到的朝霞🌅</p></blockquote><span id="more"></span><h1 id="时间过得有点快"><a href="#时间过得有点快" class="headerlink" title="时间过得有点快"></a>时间过得有点快</h1><p>上个周三还似乎历历在目，这个周三就这样猝不及防的赶来了。</p><p>在上中学的时候，望着那百来天的高考倒计时，和朋友吐槽过异常的难熬。而现在的日子似乎扎眼就过，在没有Social Media的时候虽然过得有点枯燥，但时间确是慢慢走的，留给我足够的空闲的时间去想象。现在每天拿起手机查看消息，刷屏幕，被海量的信息淹没，对时间的感知也逐渐麻木。</p><p>前一阵子看了李笑来的《和时间做朋友》还有<a href="https://survivesjtu.gitbook.io/survivesjtumanual">《上海交通大学生存指南》</a>，逐渐对时间的概念重视起来了，意识到流走的时间实在事太多了。小时候喜欢玩的游戏现在我也逐渐放下了，主要是没什么兴趣玩了，这下就多了许多时间。现在也很少去刷长视频，如果不是特别感兴趣的内容看的东西多少带着一些目标去的。但是，有一个例外，就是抖音。我真的很佩服它的产品设计，能让全球的男女老少沉迷其中。偶尔放松当然非常合适，但是时不时就容易上头，以至于脑袋里被装满各种各样的情绪垃圾。</p><h1 id="改变的习惯"><a href="#改变的习惯" class="headerlink" title="改变的习惯"></a>改变的习惯</h1><p>上大学之前，由于GFW的存在，我获取的信息仅仅局限于简中的互联网里面。但是上了大学有了网络条件这一切就有了比较大的改变了。</p><p>我知道了更多信息来源，很多时候回去尝试用英文去搜索问题，并且获得不同国家的内容观点。特别是最近我刷X特上瘾，这个软件感觉给我打造了一个舒适的泡泡，让我能第一时间就获得一些最新的消息。</p><p>这个习惯的改变不仅让我了解到了许许多多有用的知识，但我觉的更加重要的事情就是，这给了我一个新的视角去认识事情。之前单一的依赖简中环境去了解一些事情如果现在在我的视角来看就会有不同的看法，对观点和事情的包容性更强了。这点我认为非常Great。</p><h1 id="希望能睡好一点"><a href="#希望能睡好一点" class="headerlink" title="希望能睡好一点"></a>希望能睡好一点</h1><p>熬夜这个话题对我来说太沉重了，每天我都感觉睡眠不足。</p><p>每天大概睡眠时间只有六个半小时，课少还好，课多就能让我一整天无精打采。我对睡眠时间很敏感，虽然我能意识到这一点，但是做到早睡可真不容易。要想睡的好要考虑的东西也有很多，比如不能在睡前两小时吃东西。</p><p>真的好羡慕能够快速恢复精力的的人，但是尔等凡人既然没有这种能力的话，还是老老实实做到早睡早起，不要熬夜吧，不管手头有多重要的事情先放一放，好好睡觉！</p><h1 id="好好学习"><a href="#好好学习" class="headerlink" title="好好学习"></a>好好学习</h1><p>说到这个很惭愧，因为这个星期我旷了两节课。很顺利的旷课经历，大学第一次旷课感觉真的很爽！学校开的高数课，我几乎没听进去一点，真的。现在的我很慌，所以我决心好好补补我的高数课了，争取不要挂科😭。</p><p>兴趣是最好的老师，我对于学习CS还是有挺大兴趣的，希望能够坚持下去吧！我隐隐约约的感觉将来我可能真要靠这个吃饭了。</p>]]></content>
      
      
      <categories>
          
          <category> 每周回顾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>「周结#1」今天是一个值得庆祝的日子。</title>
      <link href="/2024/10/30/weekly-review2024-10-30/"/>
      <url>/2024/10/30/weekly-review2024-10-30/</url>
      
        <content type="html"><![CDATA[<p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/yublog-image/image/2024/all/w1.png"></p><h1 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h1><p>今天刷Rss的时候，看见一个站主每周一次更新自己的动态，记录下自己每一周的回顾与心得，我觉得很有意思。今天晚自习的时候，我想起来我是不是也可以自己尝试一下这种形式，记录下我的生活以及反思呢？于是便有了这个开始！每周的周三，我都会花一点时间来整理一下这七天所发生的事情，可能有某个确定的主题，也可能只是琐碎的片段。</p><span id="more"></span><h1 id="个人站点的意义"><a href="#个人站点的意义" class="headerlink" title="个人站点的意义"></a>个人站点的意义</h1><p>现在主流的社交媒体，几乎占据了每个人的生活。然而社交媒体却有许多不足之处。</p><ul><li>无法自己管理自己的数据，数据都在各大厂手里，听天由命。</li></ul><blockquote><p>个人博客可以自己管理这些数据，配图文字都在本地以及云端有备份。</p></blockquote><ul><li>社交媒体有太多不适合展示这些内容的人，以及推送算法。</li></ul><blockquote><p>我的站点暂时只在QQ签名里展示，只有主动看我资料卡的以及我的主动分享才能来到这。</p></blockquote><ul><li>社交媒体情绪化，碎片化。</li></ul><blockquote><p>我经常在某空间以及某圈宣泄那些无人在意的情绪，虽然爽了那一会，但是过一段时间后就感觉没必要了，</p><p>而在这里我可以写出更长的东西。</p></blockquote><p>我以前常常怀疑，把日常的点滴，放在几乎没人来看的网上会不会没有意义，现在我觉得这是ROI十分高的行为。也许我会在每一次生日，每一次重大的时刻的时候去组织文字，把情感固化下来。当我快忘记这些事情的时候，再回头看看曾经的文字，肯定会回味无穷。就像高三时期，我坚持写日记，特别是情感特别需要发泄的时候，虽然现在看来这些事似乎也没那么重要。如果我没有记录下高考时期的我，那么这段记忆肯定会是模糊不清的。</p><p>此外，还有一个不太明显的好处就是，这让我能通过组织文字来反思与庆祝生活中的方方面面，文字是思维的载体，这样能展现我的变化。当然，如果真有人能阅读这些我也会相当开心。</p><h1 id="保持动力"><a href="#保持动力" class="headerlink" title="保持动力"></a>保持动力</h1><p>之所以开了「周结」，最大的原因就是为我设置一个DEADLINE，我是一个很懒的人，做事很喜欢拖沓。但是设置一个时间点应该能让我坚持更新。所以今天值得被记住哈哈哈，🎉！</p>]]></content>
      
      
      <categories>
          
          <category> 每周回顾 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>得治治我的拖延症</title>
      <link href="/2024/10/21/donebetter/"/>
      <url>/2024/10/21/donebetter/</url>
      
        <content type="html"><![CDATA[<p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E6%8B%96%E5%BB%B6/tuoyan.jpg"></p><h1 id="Done-is-better-than-perfect"><a href="#Done-is-better-than-perfect" class="headerlink" title="Done is better than perfect"></a>Done is better than perfect</h1><p>不知道从什么时候开始，变得喜欢给自己找<strong>借口</strong>。</p><p>在小的时候，如果想要什么事情我总是能完全专注在其中。比如我要玩一个游戏但是却要配置许许多多东西，不知道能不能完成，但我还是会一直钻研，我想做个视频发到网站，我就会立马去下载剪辑软件录制素材。正是因为小时候这种对事情的态度，对现在的我可能还造成了不小的影响。</p><p>而现在我却很难这样二话不说，毫不忧虑的开始做一件事。这背后可能有很多的原因，比如说时间变得更紧张了，对许多事情失去了好奇心。但这些原因不是阻挡我某时某刻认真去完成某件事的直接原因，使得我拖延的是我的内心一直在和我说自己说<strong>“这件事是不是可以做的更好？”</strong>。</p><span id="more"></span><p>比如，当我决定学习编程时候，我可能会对自己说 “今天的状态是不是有点不好啊，效率会不会不高，要不要先玩会《我的世界》？”，又比如说当我突然萌生一个写一篇博文的想法，我的脑袋又会跳出一句话 “现在写这些是不是不合适，我是不是会写一些垃圾出来，要不再等等？”</p><p>有的时候我借助这<strong>力求完美</strong>这个借口为自己的行为开脱，也有些时候我确实因为惧怕<strong>不够完美</strong>而无法迈出自己的第一步。而现在想想，无论做什么事情，似乎只有做起来才是真正重要的事情。因为大多的时候我们会因为这些顾虑而不断<strong>拖延</strong>。</p><h1 id="接受不完美"><a href="#接受不完美" class="headerlink" title="接受不完美"></a>接受不完美</h1><p>存在着一小部分，它们有着非凡的自驱力，可以顺利完成自己规划的事情。但对于资质平庸的我，似乎把追求完美放在首位并不太可靠，因为没有动力，热情来维持行动。</p><p>当我开始做一件事情的时候，那这件事情注定会存在问题，就像世界上没有完美的人，世界上也不会存在完美的事。所以不用担心自己会不会把事情弄得太糟，担心自己会不会没有效率。当我们真正完成了某件事，那它就已经完成了，永远都比还没有行动要好。我们可以不断的改善。</p><h1 id="想做就做！"><a href="#想做就做！" class="headerlink" title="想做就做！"></a>想做就做！</h1><p>最近这两天感觉自己学习效率又降了不少，感觉就像一条正弦曲线有升有降。今天在看Cherno时候看到这个观点，感觉非常的适合我。因为我就是老喜欢拖延，放下正事刷抖音玩游戏。但实际上如果开始做了，那么还是很容易保持专注的。希望接下来能有说干就干的状态吧！</p>]]></content>
      
      
      <categories>
          
          <category> 最近的事~ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP笔记</title>
      <link href="/2024/10/15/cppnote/"/>
      <url>/2024/10/15/cppnote/</url>
      
        <content type="html"><![CDATA[<p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/CPP%E7%AC%94%E8%AE%B0/cppnote_page.jpg"></p><p>本篇主要在于记录一下我学CPP的过程，内容基于自己的理解。</p><span id="more"></span><h1 id="2024年10月15日"><a href="#2024年10月15日" class="headerlink" title="2024年10月15日"></a>2024年10月15日</h1><p>1.为什么用void，因为你有时候定义一个函数并不要求他要返回什么东西，<strong>只是关注于他能做什么事情。</strong></p><p>2.为什么要有函数，因为当你想要实现某种功能的时候，<strong>你无需重复复制粘贴</strong>，只需要调用函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个返回两个数乘积的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Mutiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 MutiplyAPP 函数，调用 Mutiply 并输出结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MutiplyAPP</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">Mutiply</span>(a, b); <span class="comment">// 调用 Mutiply 计算乘积</span></span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 输出结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MutiplyAPP</span>(<span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 调用 MutiplyAPP 函数</span></span><br><span class="line">    <span class="built_in">MutiplyAPP</span>(<span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">    std::cin.<span class="built_in">get</span>(); <span class="comment">// 等待用户输入，防止程序结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>只有主函数 <strong>int main</strong>不用返回一个值，因为他会自动假设返回0.</li><li>头文件其实很有用，他的用途不只是声明，以供你在多个CPP中使用.在基础中，头文件传统上是用来声明某些函数类型，一遍用于整个函数，我们需要一个共同的地方来存放函数，只是声明，没有函数的主体。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>; #这就是上面那个函数的签名</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;lll&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是告诉源2那个函数所在位置的方法。但是如果我们需要在别处用到呢？我们难道要复制粘贴吗？头文件在这的作用就发挥出来看了，他可以复制粘贴 <strong>函数</strong>到我们需要用这个函数的地方。</p><p>检查include有没有重复引用的方法</p><ol><li>头文件生成时自带#pragma once</li><li>还有一种 <strong>ifentif</strong></li></ol><p>为什么有有时候用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include&lt;stdio.h&gt;</span><br></pre></td></tr></table></figure><p>而有时候是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include<span class="string">&quot;Log.h&quot;</span></span><br></pre></td></tr></table></figure><p>因为引号”” <strong>可用于相对位置的头文件,而</strong> &lt;&gt;却只能用于 某一些 头文件,这些头文件都可以用引号表示.</p><p>扩展名问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include&lt;iostream&gt;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include&lt;stdio.h&gt;</span><br></pre></td></tr></table></figure><p>**C++**都没有扩展名,<strong>C</strong>却大多有扩展名,这也是区分标准库属于哪的判断依据.</p><h1 id="2024年10月17日"><a href="#2024年10月17日" class="headerlink" title="2024年10月17日"></a>2024年10月17日</h1><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>当我们有一个条件指向一个分支的时候，我们就是在告诉我们的电脑，<strong>嘿，快跳到这个内存地址，执行这个指令</strong>。</p><p>许多高效的代码可能避免<strong>分支结构</strong>，可能内存中指令和分支距离较远时候会带来效率问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">bool</span> compare = x == <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (compare);</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">InitLog</span>();</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再这行代码里，布尔 <strong>bool</strong>判断x是否为5，如果则打印（<strong>compare &#x3D;&#x3D; true</strong>）.</p><h1 id="2024年10月18日"><a href="#2024年10月18日" class="headerlink" title="2024年10月18日"></a>2024年10月18日</h1><h2 id="FOR循环以及WHILE循环"><a href="#FOR循环以及WHILE循环" class="headerlink" title="FOR循环以及WHILE循环"></a>FOR循环以及WHILE循环</h2><p><strong>FORLOOP</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> #打印五次</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello ,world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>for</strong>循环需要三个要素，分别为 初始化表达式，条件表达式（比较或者是布尔值），增量表达式。在这个循环中首先先定义变量，然后在判断是否符合条件，符合执行函数，然后在进行增量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//打印五次</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>；</span><br><span class="line"><span class="keyword">for</span> (; i &lt; <span class="number">5</span>; )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello ,world\n&quot;</span>);</span><br><span class="line">i++；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可也把赋值放在前头，增量放在后头。</p><p><strong>WHILELOOP</strong></p><p>和for循环差不多，但是没有第一个初始化表达式以及第三个增量表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//打印五次</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ( i &lt; <span class="number">5</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello ,world\n&quot;</span>);</span><br><span class="line">i++；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DO WHILE</strong></p><p>不同于while，即使开始条件就不满足，它也至少会执行一次。</p><h2 id="用哪个"><a href="#用哪个" class="headerlink" title="用哪个"></a>用哪个</h2><p>通常取决于是否需要新变量，选择通常看个人风格。有布尔值判断是否循环一般用WHILE。一般遍历数组时候，数字的大小确定用FOR</p><h2 id="控制流语句"><a href="#控制流语句" class="headerlink" title="控制流语句"></a>控制流语句</h2><p>控制流语句通常和循环一起使用，这样我们就能更好的控制循环。</p><p>有三个主要的控制流语句 <strong>continue</strong>\ <strong>break</strong> \ <strong>return</strong>。</p><p>continue只能用于循环内部，如果还能迭代的话，直接进行下一次迭代，否则终止循环。</p><p>break主要用在循环里，但也经常用在swich语句中。它的功能是直接跳出循环。</p><p>return可以直接结束循环，需要返回值。</p><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//打印五次</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)<span class="comment">// 如果余数取值0</span></span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">// 则进行下一次迭代</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello,World \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像这样，当i为 0， 2， 4时候，不执行打印函数。直接跳到i++。</p><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>) <span class="comment">// 当 i 等于 5 时退出循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>只要调节为真，就立马跳出循环。</p><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//打印五次</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i&gt;<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello,World \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">```c++</span><br><span class="line"></span><br><span class="line">这是一个需要返回整数的函数,因为函数开始就已经定义了**<span class="type">int</span>类型**，如果<span class="keyword">if</span>是真，那么他会**直接关闭我们的程序**，后面代码都不会执行。</span><br><span class="line"></span><br><span class="line">另外一点不同于上面两个函数的是，<span class="keyword">return</span>函数不仅仅局限于函数内部，**也可以在函数外部。**直接在一个地方写个<span class="keyword">return</span> <span class="number">0</span>就可以结束函数。 </span><br><span class="line"></span><br><span class="line">一定要注意如果函数需要返回一个值，那么一定要<span class="keyword">return</span>一个值。</span><br><span class="line"></span><br><span class="line">## 什么控制了语句</span><br><span class="line"></span><br><span class="line">控制流语句控制了程序的运行。</span><br><span class="line"></span><br><span class="line">这些IF语句，条件语句，循环，控制流，就是逻辑编程的核心，是用来修改程序运行情况的唯一工具。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">2024</span>年<span class="number">10</span>月<span class="number">19</span>日</span><br><span class="line"></span><br><span class="line">## 指针</span><br><span class="line"></span><br><span class="line">指针对于控制内存在的数据极为重要。</span><br><span class="line"></span><br><span class="line">所有类型的指针都是一个整数，存放着一个内存地址，类型不会改变指针，指针永远只是一个地址。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="type">void</span> *ptr = <span class="number">0</span> <span class="comment">//这是一个没有类型的，无效指针，0/null 代表无意义，但可以存在。</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="type">void</span> *ptr = &amp;var;<span class="comment">//取出地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想找到变量var在内存中存放的地址，就用**&amp;<strong>运算符。在变量前加&amp;实际上就是在问：</strong>hi，你的地址是什么**。</p><p>当我们知道变量var的地址，那我们怎么才能<strong>读取或改写</strong>？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> var = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;var;</span><br><span class="line">*ptr = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//取出地址，int类型告诉编译器，指指针*ptr应该以整数的形式，存储这个数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个指针只指向内存中的一个位置，而不是指向一块内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* p = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">8</span>];、</span><br><span class="line"><span class="comment">//分配8个字节，然后把这块内存开始的地址存到一个指针里。</span></span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"><span class="comment">//用数字0填充这8个字节</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="comment">//清理内存，防止overflow</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>new底层其实是call了malloc，malloc是memory allocation的简写，从名字也可以知道它负责分配内存，delete则调用了free()，区别是new和delete不仅管理内存，还会调用constructor和destructor，另外它们都是operator，所以你可以重载它们，做一些有趣的事情。对了，new【】和delete【】其实另两个operator，它们做的事情稍微有点不一样，你调用new【】的时候，必须要指定一个size，但调用delete【】的时候，并没有指定size，它怎么知道delete多少呢？这是因为new【】不仅分配了所需要的内存，还会多分配一个额外的空间，来存储这个size，所以以视频中的举例，它所做的是分配这样一块内存【8, 0, 0, 0, 0, 0, 0, 0, 0】，连续的，但是多一块在最前面，但是return给你的是跳过那块内存的地址，比如malloc返回的是0x1，但new【】给你返回的是0x1+2（我记得它分配的是一个word（一般是short）的大小，具体大小需要看系统），然后在delete【】的时候，它会往前推一个word，因为它知道前面一个word肯定是size，从而拿到size，进而delete所有）</p></blockquote><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在计算机如何处理引用与指针这两个关键词上来看，他两其实是一回事。当然如何写它，如何用它还是有点不同的。</p><p>引用只是指针的一块语法糖，使得指针更易读更好学。</p><p>引用，正如其名，对于某个已存在变量的引用。对于指针可以创建一个0指正，但是引用不能这么做。因为“引用变量”必须引用一个已存在的变量，他本身并不是一个新的变量，他们并不真正的占用内存，存储数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a</span><br><span class="line"><span class="comment">//变量类型后➕&amp;就是指的是引用变量！</span></span><br><span class="line"><span class="comment">//ref不是一个真正的变量名，它不存在于内存！</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ref他不是一个变量！他只是a的一个别称。不需要写一些奇怪的字符，只需要让它等于那个已存在的变量即可。</p><p>到目前为止我们就创建了<strong>别名</strong>，他只是为已引用对象所取的另外一个名字。</p><p>若是我们想让a值增加，通过以下函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increament</span><span class="params">(<span class="type">int</span>* value)</span></span></span><br><span class="line"><span class="function"><span class="comment">//把函数的形参变为一个 指针，这样就能把a的内存地址传入函数，而不是a本身</span></span></span><br><span class="line"><span class="function"><span class="comment">//传递变量的内存地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(*value)++;</span><br><span class="line"><span class="comment">//这里必须改为解引用，不然加的就是地址本身了</span></span><br><span class="line"><span class="comment">//由于顺序问题加括号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="built_in">Increament</span>(&amp;a);</span><br><span class="line"><span class="built_in">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>传址，如果是传值无法改变a的值，只是copy一下生成了一个 int value &#x3D; 5</p></blockquote><p>然而通过引用，我们可以更加简单的实现以上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increament</span><span class="params">(<span class="type">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"><span class="comment">//这儿的int&amp; value就是代表一个引用变量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">value++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">Increament</span>(a);</span><br><span class="line"><span class="built_in">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就像这样</p><p>没有什么是引用能实现，而指针不能，指针很像引用，但是它的功能更强大，而引用能让代码具有更高的可读性，更加简洁。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>简而言之，就是把<strong>数据以及函数</strong>，结合在一起。</p><p>当我们想生成一个游戏，有许多玩家，这当中必定涉及许多变量，定义他们会造成混乱，难以维护和继续。</p><p>但我们可以生成一个<strong>类</strong>叫做Player，一次性包含所有数据，最终作为一种类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std :: cout &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> speed;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建全新的类别叫做 player</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Player  player;</span><br><span class="line"><span class="comment">//这里我们创建了一个类型为Player，叫做player的对象</span></span><br><span class="line"><span class="comment">//新创建对象的过程叫做实例化，这儿我们实例化了一个叫做player的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>player对象无法访问类中的私有成员，因为有种东西叫做访问控制。当我创建一个类时，我可以指定属性的私有性，但是默认类中成员的访问控制都是私有的，意味着只有内部函数才能访问这些变量。</p><p>对象拥有类定义的所有属性和方法，它们是类的具体表现形式。每个对象都<strong>有自己独立的数据</strong>，但共享类的行为。</p><p>如果我们想要角色移动到某一个位置，该怎么办呢，我们可以构造一个函数。</p><p>类内可以写函数，类内的函数叫做方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std :: cout &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> speed;</span><br><span class="line"><span class="comment">//创建全新的类别叫做 player,并且设置为公开</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">( <span class="type">int</span> xa, <span class="type">int</span> ya )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x += xa * speed;</span><br><span class="line">y += ya * speed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在类内添加函数，称为方法，写在里面不需要（Player&amp; player,）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Player  player;</span><br><span class="line"><span class="comment">//这里我们创建了一个类型为Player，叫做player的对象</span></span><br><span class="line"><span class="comment">//新创建对象的过程叫做实例化，这儿我们实例化了一个叫做player的对象</span></span><br><span class="line">player.<span class="built_in">move</span>( <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2024年10月20日"><a href="#2024年10月20日" class="headerlink" title="2024年10月20日"></a>2024年10月20日</h1><h2 id="结构体和类的区别是什么"><a href="#结构体和类的区别是什么" class="headerlink" title="结构体和类的区别是什么"></a>结构体和类的区别是什么</h2><p>我们很容易对什么时候使用struct与class而感到困惑，它们基本没什么区别。</p><p><strong>唯一的区别是</strong></p><p>类默认情况下<strong>是私有的</strong>，如果我们要调用它必须有特殊的声明，而结构体默认<strong>是公有的</strong>，例如，我们可以直接把类改为结构体，这样不用public也不会报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(x) std :: cout &lt;&lt; x &lt;&lt; std :: endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//未设置公开，改为struct</span></span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> speed;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> xa, <span class="type">int</span> ya)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x += xa * speed;</span><br><span class="line">y += ya * speed;</span><br><span class="line">&#125;）</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Player  player;</span><br><span class="line">player.<span class="built_in">move</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，如果我们要它变成私有，必须标识<strong>private</strong>。</p><p>作用上他两没有实际上没有太大的区别，<strong>C++中结构体存在的唯一原因是，是他想要维持与C之间的兼容性</strong>，因为C没有类，然而他有结构体，如果我们突然删除struct这个关键词，那他就会失去所有的兼容性。</p><p>实际的使用场景会有所不同，因为每个人的理解都有不同，受到个人编程风格习惯的影响。</p><p>当仅仅是一些变量和操纵变量的函数是，偏向于结构体。</p><p>绝对不会对结构体使用继承，继承增加了一层复杂性，我希望我的结构体仅仅是数据的结构体。</p><h2 id="如何写类"><a href="#如何写类" class="headerlink" title="如何写类"></a>如何写类</h2><p>学会编写一个基本的Log类。</p><p>实现一下</p><p>像控制台中写入文本。错误，警告（打印警告，但不会跟踪信息），消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//简单的日志记录系统。我们可以通过设置日志级别来控制哪些日志信息会被打印输出。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LogLevelError = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LogLevelWarning = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LogLevelInfo = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//书写习惯，把常量和定义分开写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_LogLevel = LogLevelInfo;</span><br><span class="line"><span class="comment">//m用来提示这是一个私有类的成员变量</span></span><br><span class="line"><span class="comment">//用来记录当前日志记录器的日志级别，默认为 LogLevelInfo（2）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> Level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_LogLevel = Level;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//置日志级别，将传入的日志级别值赋给 m_LogLevel。这决定了后续哪些日志会被记录。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_LogLevel &gt;= LogLevelError)</span><br><span class="line"><span class="comment">//日志级别为 0 或更高，则输出错误信息。</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[Error]&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_LogLevel &gt;= LogLevelWarning)</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[Warning]&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_LogLevel &gt;= LogLevelInfo)</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[Info]&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Log log;</span><br><span class="line"><span class="comment">//实例化过程，实例化一个叫log的对象</span></span><br><span class="line"></span><br><span class="line">log.<span class="built_in">SetLevel</span>(log.LogLevelError);</span><br><span class="line"><span class="comment">//设置级别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置一个日志级别，意味着只会打印警告或更重要的消息</span></span><br><span class="line">log.<span class="built_in">Warn</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">log.<span class="built_in">Error</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">log.<span class="built_in">Info</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样，当我们将级别设置为Info时候，所有信息都会被打印出来，而设置Error则只会打印出来Error的信息</p></blockquote><h2 id="关键字Static"><a href="#关键字Static" class="headerlink" title="关键字Static"></a>关键字Static</h2><p>CPP中的关键字根据上下文有两种意思。</p><p>一种是在结构体Struct或者是类Class外的，另一种则是在结构体或者类里的。</p><p>有点像类里的Private，变量和函数同理。</p><p>Static variable（静态变量）Static function(静态函数)只对它声明的CPP文件可见。</p><p>假如我们在头文件中定义了静态变量，然后在两个CPP文件中包含了这个头文件，某个变量其实在两个编译单元都被定义了，这就是静态变量在头文件中的作用，防止重复定义。</p><h3 id="类与结构"><a href="#类与结构" class="headerlink" title="类与结构"></a>类与结构</h3><p>Static如果在一个类里或者是结构里，静态意味着特定的东西。如果和变量一起使用，意味着在类的所有实例中，这个变量只有一个实例，意思是如果某个实例如果改变了这个静态变量，那么它会在所有实例中反映这个变量变化，也因此，<strong>通过类实例来引用静态变量是没有意义的</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value; <span class="comment">// 静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 推荐的访问方式</span></span><br><span class="line">    std::cout &lt;&lt; MyClass::value &lt;&lt; std::endl; <span class="comment">// 直接通过类名访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不推荐的访问方式</span></span><br><span class="line">    MyClass obj;</span><br><span class="line">    std::cout &lt;&lt; obj.value &lt;&lt; std::endl; <span class="comment">// 通过对象访问，但实际上它还是属于类的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过类实例来引用静态变量是没有意义的</p></blockquote><p>因为每个非静态方法总是获得当前类的一个实例作为参数，这就是类在幕后的工作方式。它们通过隐藏的参数发挥作用，静态方法不回得到那个隐藏参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> nonStaticVar;  <span class="comment">// 非静态成员变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;  <span class="comment">// 静态成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; nonStaticVar;  // 错误！静态方法不能访问非静态成员</span></span><br><span class="line">        std::cout &lt;&lt; staticVar;  <span class="comment">// 可以访问静态成员</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; nonStaticVar;  <span class="comment">// 可以访问非静态成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::staticVar = <span class="number">10</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>静态方法无法访问非静态成员的原因</p></blockquote><h3 id="类-结构体外"><a href="#类-结构体外" class="headerlink" title="类&#x2F;结构体外"></a>类&#x2F;结构体外</h3><p>类外的Static修饰的符号在Link阶段是局部的，也就是他只对定义他的.Obj（编译单元）可见</p><p>类外的 <code>static</code> 关键字主要用于<strong>全局变量</strong>和<strong>全局函数</strong>，它们的作用是<strong>限制作用域</strong>。具体特性如下：</p><ul><li><strong>作用域</strong>：类外的 <code>static</code> 变量和函数仅在声明它们的文件内可见。也就是说，它们的作用域限制在定义它们的文件中，其他文件无法访问它们。</li><li><strong>生命周期</strong>：这些 <code>static</code> 变量在程序开始时就被创建，并在程序结束时销毁，它们的生命周期是整个程序运行期间。</li><li><strong>用途</strong>：可以防止全局命名冲突，因为静态全局变量或函数不会被其他文件看到，从而避免了不同文件中同名变量或函数的冲突。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stastic <span class="type">int</span> s_Variable = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//Stastic表示这个变量在link时候只对这个.cpp里的东西可见</span></span><br><span class="line"><span class="comment">//Link它的实际定义时候，Linker不回在这个编译单元外找它的定义</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="类-结构体内"><a href="#类-结构体内" class="headerlink" title="类&#x2F;结构体内"></a>类&#x2F;结构体内</h3><p>而类内的<code>stastic</code>表示内存是这个类中所有实体所共享的，就算是实例化了很多次这个类&#x2F;结构体，那个静态变量也只会有一个实例</p><ol><li><h4 id="静态成员变量的定义与特点"><a href="#静态成员变量的定义与特点" class="headerlink" title="静态成员变量的定义与特点"></a><strong>静态成员变量的定义与特点</strong></h4></li></ol><ul><li>当你在类中定义一个 <code>static</code> 成员变量时，这个变量属于<strong>类本身</strong>，而不是任何一个对象。它在内存中只存在一次，不管有多少个对象被创建，这个静态成员变量都是共享的。</li><li>因为它是类的一个属性，所以在类的所有对象之间，它的值是共享的。如果一个对象修改了这个静态变量的值，其他对象也会看到这个变化。</li></ul><ol start="2"><li><strong>具体例子</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">// 静态成员变量声明</span></span><br><span class="line">    <span class="built_in">Counter</span>() &#123;</span><br><span class="line">        count++; <span class="comment">// 每创建一个对象，count 自增</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Counter::count = <span class="number">0</span>; <span class="comment">// 静态成员变量定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Counter c1; <span class="comment">// 第一个对象，count 变为 1</span></span><br><span class="line">    Counter c2; <span class="comment">// 第二个对象，count 变为 2</span></span><br><span class="line">    Counter c3; <span class="comment">// 第三个对象，count 变为 3</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; Counter::count &lt;&lt; std::endl; <span class="comment">// 输出：Count: 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>Counter::count</code> 是一个静态成员变量，属于 <code>Counter</code> 类。</li><li>每次创建一个 <code>Counter</code> 对象时，<code>count</code> 都会增加 1。因为这个 <code>count</code> 是静态的，所以无论创建多少个对象，它们都访问的是同一个 <code>count</code> 变量。</li><li>最终，无论你访问哪个对象的 <code>count</code> 或者直接通过 <code>Counter::count</code> 访问，它们都是指向同一个内存位置，即<strong>这个变量在整个程序中只有一个实例</strong>。</li></ul><ol start="3"><li><strong>理解共享内存</strong></li></ol><ul><li><strong>为什么共享？</strong>：因为静态变量不属于单个对象，而是属于整个类。所以它在类的所有对象之间都是共享的。这就像类的一个全局属性，无论创建多少个对象，它们访问的都是同一个变量。</li><li><strong>内存模型</strong>：假设我们有一个类 <code>MyClass</code>，并创建了 100 个 <code>MyClass</code> 对象，如果这些对象中有一个普通的非静态成员变量 <code>x</code>，那么每个对象都有自己独立的 <code>x</code>，在内存中会有 100 个 <code>x</code> 的副本；但是，如果是一个静态成员变量 <code>y</code>，那么这 100 个对象访问的都是同一个 <code>y</code>，在内存中只有一个 <code>y</code> 实例。</li></ul><ol start="4"><li><strong>实际意义</strong></li></ol><ul><li>静态变量可以用于<strong>统计类对象的个数</strong>、<strong>共享类级别的数据</strong>或<strong>控制某些类级别的行为</strong>。比如，在单例模式中，我们通常使用静态变量来确保类只创建一个实例。</li></ul><blockquote><p>ByChatGPT</p></blockquote><h3 id="Extern"><a href="#Extern" class="headerlink" title="Extern"></a>Extern</h3><p>当我们有多个编译单元时候，在一个编译单元定义了一个变量，却没有用<code>static</code>,那么我们怎么在另一个单元里调用这个变量呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是1.ccp</span></span><br><span class="line"><span class="type">int</span> Variable = <span class="number">5</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> Variable</span><br></pre></td></tr></table></figure><p>通过<code>Extern</code>我们就可以实现在另外的编译单元找定义，也叫外部链接 <strong>External linking</strong></p><h1 id="2024年10月22日"><a href="#2024年10月22日" class="headerlink" title="2024年10月22日"></a>2024年10月22日</h1><p>不更新了,知乎找到一个博主笔记,写的比我好得多</p>]]></content>
      
      
      <categories>
          
          <category> NOTE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>咖啡因与尼古丁</title>
      <link href="/2024/09/26/fucknicotin/"/>
      <url>/2024/09/26/fucknicotin/</url>
      
        <content type="html"><![CDATA[<p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E5%B0%BC%E5%8F%A4%E4%B8%81/smoke.jpg"></p><blockquote><p>高中放假后最快乐事情之一</p></blockquote><p>这篇主要在激励自己<strong>戒除香烟以及咖啡因</strong>，并且细数一下这两给我造成的影响。</p><p>在此之前我已经很多次决定<strong>戒烟</strong>，实际上我抽的烟并不多，我的吸烟习惯不算规律，有时一两天就能抽完一包烟，有时几天才抽一根。</p><p>而<strong>咖啡因</strong>摄入来源主要是咖啡，但我意识到我成瘾时我也很快决定戒掉，坚持了一个月直到现在。</p><span id="more"></span><h1 id="关于香烟🚬"><a href="#关于香烟🚬" class="headerlink" title="关于香烟🚬"></a>关于香烟🚬</h1><h2 id="为什么抽烟"><a href="#为什么抽烟" class="headerlink" title="为什么抽烟"></a>为什么抽烟</h2><p>我记得第一次抽烟纯纯是因为好奇，想着为什么那么多人热衷于叼着一根香烟。而且平均一包30左右的价格还有大把人乐此不疲的抽。</p><p>所以大概在我高一吧，买了人生中第一包烟，然而并不会抽，专业一点讲就是不会过肺抽起来没有感觉。</p><p>事情最好就停在这了，然而到了高二，一次偶然的机会，我真正的抽上了第一口过肺的香烟，<strong>尼古丁</strong>迅速上脑使我头晕，镇静，我立马倒在学校宿舍床上好一会才缓过来。</p><p>随后，高中日复一日的枯燥学习，没事来口烟就是对大脑十分新奇的事了，抽烟带来的那种奇妙的感觉也就很顺理成章的为我埋上了一颗<strong>上瘾</strong>的种子。</p><p>当我决定好要戒烟的时候，总是容易被外界刺激而导致失败。<strong>比如以下这些情况：</strong>刷视频看到别人抽，看到朋友抽，自己特别难过或特别兴奋的时候… 总之有各种各样的诱因会在我意识薄弱的时候击碎我的毅力。</p><h2 id="为什么要戒烟"><a href="#为什么要戒烟" class="headerlink" title="为什么要戒烟"></a>为什么要戒烟</h2><p>抽烟固然很爽，但却对身体有着十分显著的<strong>危害</strong>。</p><p>就个人来说，我属于<strong>易过敏体质</strong>，平时牛奶喝的多了都会容易长痘痘。当我抽了一段时间后我能很明显的感觉到我的过敏反应，流鼻涕这种。并且尼古丁对我的皮肤有很大的影响，据我观察，只要我吸烟，我绝对会长痘。</p><p>再者，香烟与各种重大疾病都有很大的关联，这点就不多说了，我还想<strong>活久一点</strong>。</p><p>对我来说最大的影响可能就是明知有害却仍然做这件事的<strong>负罪感</strong>，这种感觉使我非常难受。</p><p>所以，为了我的钱包，皮肤，心理还有身体考虑，<strong>舍弃</strong>那点快感也是值得的。</p><h1 id="咖啡因☕️"><a href="#咖啡因☕️" class="headerlink" title="咖啡因☕️"></a>咖啡因☕️</h1><h2 id="戒咖啡"><a href="#戒咖啡" class="headerlink" title="戒咖啡"></a>戒咖啡</h2><p>有段时间我几乎一天至少一杯咖啡，特别是上午困倦的时候，来一杯简直可以一秒精神。</p><p>不过有段时间我断了一会咖啡，那一整天不喝就没精神。后来我查了一些资料，总结来说咖啡因也具有<strong>成瘾性</strong>，会有戒断反应。尽管这个戒断反应不是很久，但有时候难免会喝不到咖啡从而造成心理折磨。</p><p>对睡眠的影响也很大，白天喝咖啡晚上就会经常做梦，睡的不是很好。而戒掉咖啡的<strong>睡眠</strong>的影响十分巨大，对我精神状态很好的改善。</p><p>我应该不需要依靠<strong>External</strong>的物质就能掌控自己的身体。</p><h2 id="COKE"><a href="#COKE" class="headerlink" title="COKE"></a>COKE</h2><p>可乐这个暑假我几乎天天喝，这可能就是咖啡因在作祟吧，永远就只有第一口的可乐最爽。</p><p>但为了减少摄入咖啡因，所以可乐要少喝了，开始喝雪碧！</p><div class="note info">            <p>开始戒烟！ </p>          </div>]]></content>
      
      
      
        <tags>
            
            <tag> 心得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学军训</title>
      <link href="/2024/09/19/%E5%A4%A7%E5%AD%A6%E5%86%9B%E8%AE%AD/"/>
      <url>/2024/09/19/%E5%A4%A7%E5%AD%A6%E5%86%9B%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E5%86%9B%E8%AE%AD/%E5%A4%A7%E5%AD%A6%E5%86%9B%E8%AE%AD.jpg"></p><div class="note success">            <p>军训从小到大也经历了许多回，初一高一高三，每次军训都给我留下了很深的印象，这次大学开学军训🥲也不例外 </p>          </div><h1 id="周期长，时间很难熬"><a href="#周期长，时间很难熬" class="headerlink" title="周期长，时间很难熬"></a>周期长，时间很难熬</h1><p>这一点很值得一提，初中高中军训周期都很短，7到14d，这个时间属于刚好不用吃很多苦头就能留下难忘经历的训练周期</p><p>而大学军训有21d，还有十天结束我已经十分疲倦了。早上五点半起床晚上十一点半入睡，我的睡眠需求在7.5➕，加上训练，真的难受</p><p>每天来回路上都是鸟语花香，打哈切从早到晚，睡眠不足真的很煎熬。洗完衣服玩会手机就能闭眼睡着</p><span id="more"></span><p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E5%86%9B%E8%AE%AD/%E5%86%9B%E8%AE%AD666.jpg"></p><h1 id="训练够累"><a href="#训练够累" class="headerlink" title="训练够累"></a>训练够累</h1><p>经常刷到 <strong>敬礼不放手，正步不松腿，齐步不松臂</strong> 都会笑一下，没想到这事真落我头上了。隔壁排天才教官还发明出来了敬礼➕抬腿</p><p>对于<strong>定动作</strong>这回事，上半身偷懒要难于下半身，正步定腿可以偷偷放下不是很明显，但敬礼，齐步抬手就很难了，非常容易被发现</p><p>这十天下来，最累的应该是走正步，走的时候定住那么一会儿要靠核心力量收紧防止摔倒，还要把腿高高抬起，整上那么三四回，真的酸爽</p><p>军训的累😮‍💨其实很大程度我觉得是因为<strong>睡眠不足</strong>，每天都能恰到好处的压榨完我所有的精力</p><p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E5%86%9B%E8%AE%AD/junxun.jpg"></p><h1 id="军训有啥用？"><a href="#军训有啥用？" class="headerlink" title="军训有啥用？"></a>军训有啥用？</h1><p>教官说军训能提升我们的集体意识和爱国意识</p><p>爱国这个点就很值得怀疑，爱国我觉得应该由心而发，一个不爱国的人会不会经过这一段军训就爱国了么</p><p>再说 <strong>『集体利益高于一切』</strong> 这个观点，我觉得是非常不对的。在军训下，我们必须 <strong>服从指挥</strong>，这是反人性的，每个人的自由意志都被抑制。如果在军队中，服从指挥往往是有参军的梦想，以及<strong>荣誉</strong>。而似乎军训教导给我们更多的似乎是要<strong>好好听话</strong></p><p>不过在集体上，军训能让我们对彼此更加了解，起到破冰🧊的作用</p><p>军训存在可能是它之前已经存在了，军训汇演可以让领导们眼前一亮</p><p>对于我个人来说，14d左右的军训还是很有意思，拉回到高三7d的军训，天天都乐呵呵的，教官很好相处，特有意思。两个人面对面憋笑这个事我到现在还觉得很有意思，留下了很深刻的印象</p><p>这次军训虽然没有结束，但最累的十天已经过去了，正是因为高强度的训练，这段回忆才会尤为深刻，在多年以后某个时刻回忆起大学就能立马想起军训这段时光</p><h1 id="IN-A-NUTSHELL"><a href="#IN-A-NUTSHELL" class="headerlink" title="IN A NUTSHELL"></a>IN A NUTSHELL</h1><p>军训我觉得可以有但是时间应该短点，21d实在是太长了。它有许多可以诟病的地方，但却是我刚迈进大学的一段难忘时光，并且会在之后的日子当中日久弥新。</p>]]></content>
      
      
      <categories>
          
          <category> 最近的事~ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心得 </tag>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初见大学</title>
      <link href="/2024/09/09/%E5%88%9D%E8%A7%81%E5%A4%A7%E5%AD%A6/"/>
      <url>/2024/09/09/%E5%88%9D%E8%A7%81%E5%A4%A7%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E5%BC%80%E5%AD%A6/%E5%88%9D%E8%A7%81%E5%A4%A7%E5%AD%A6.jpg"></p><h1 id="开学前"><a href="#开学前" class="headerlink" title="开学前"></a>开学前</h1><div class="note success">            <p>这个暑假是上学有史以来最长的暑假。  </p>          </div><p>从6月9日高考结束到开学9月1日，三个月的假期几乎没有计划地就度过了，每天吃喝睡然后刷抖音。夏天全国都很热🥵，偶尔出去玩一会都热的非常难受，尤其在长沙！</p><p>所以假期到后面便开始呈现一种虚无之感了，可能对我这样玩太久也会很难受吧哈哈。</p><p>临近开学便开始期待了，期待高三想象中的大学生活（主要是美好的一面），以及到一个新的环境也会让我兴奋。所以我还是很期待开学的，但中间也曾担忧会被分到8人寝室，所以还有一丝开盲盒的感觉。</p><span id="more"></span><h1 id="报道"><a href="#报道" class="headerlink" title="报道"></a>报道</h1><p>坐高铁直接就到常德站。</p><p>初次见面这座城市，给我一种很轻切的感觉，当地的方言说快了我就有点听不太明白，但确很亲切。这座被称为<strong>桃花源的城市</strong>，文旅宣传很到位，出租车也全都是粉色的。</p><p>到校没多久，学校安排的志愿者就来引导我入校，一切都很顺利，我打开了寝室的大门。</p><p>四个人的寝室，大家都已经到了，空间我觉得还是比较宽敞的，运气不错的是大家都很好相处很有礼貌。大家合力把宿舍整理干净,开学干啥都一起走。</p><p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E5%BC%80%E5%AD%A6/kaixue.jpg"></p><blockquote><p>好乱的桌子！！</p></blockquote><h1 id="听会"><a href="#听会" class="headerlink" title="听会"></a>听会</h1><p>开学开了许多会。</p><p>就我个人，其实挺不喜欢听会的。大多数听的会无非就是看<strong>PPT中插入的视频</strong>，而且有许多自己不关心的事情。加之天气异常的闷热，就很难受 <strong>:(</strong></p><p>然后，会上提到第二课堂和易班我觉得很难评，这些懂得都懂。</p><p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E5%BC%80%E5%AD%A6/lib1.jpg"></p><p><img src="http://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E5%BC%80%E5%AD%A6/lib2.jpg"></p><blockquote><p>学校的图书馆开灯看起来挺好看</p></blockquote><h1 id="军训"><a href="#军训" class="headerlink" title="军训"></a>军训</h1><p>军训21天，我真的怀疑人生。太多可以吐槽的了，我觉得军训真的大可不必，有点没苦硬吃那种感觉。</p><p>首先是统一服装，学校80块一套的军训服，真特么的难穿，穿着身上还哪哪都不舒服。每天5点早起穿上这套衣服感觉天要塌了。</p><p>教官是我们学校的学生，军训从小开始，差不多轻车熟路，但是站在那一动不动真的很难受。每天听着命令<del>使唤</del>，真的是一种折磨。</p><p>每天最期待的事情就是吃饭，不管吃啥都能把饭吃的干干净净。学校食堂物价一般，但口味确实还行，看着很干净也很好吃，特别是学校的米我觉得很好吃。</p><p>军训没和几个人熟悉，熟悉的人仅仅只有舍友，我觉得这样也挺好。</p><h1 id="扯几句"><a href="#扯几句" class="headerlink" title="扯几句"></a>扯几句</h1><p>最近在找合适的图床，真不想要用腾讯家的对象存储，如果找到合适的以后可以多配几张图片了。</p>]]></content>
      
      
      <categories>
          
          <category> 最近的事~ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语语法入门</title>
      <link href="/2024/08/26/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/"/>
      <url>/2024/08/26/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="英语语法入门"><a href="#英语语法入门" class="headerlink" title="英语语法入门"></a>英语语法入门</h1><p>关于英语语法一些基本要素的笔记,自己整理一下.</p><span id="more"></span><h1 id="造句-Construct"><a href="#造句-Construct" class="headerlink" title="造句 Construct"></a>造句 Construct</h1><p>主语Subject(人或物) ＋ 谓语Predicate(动作或发生了什么事)</p><p>五种<strong>基本句型</strong>如下,加粗为<strong>谓语动词</strong>,斜体为<em>宾语</em>,删除线为<del>补语</del></p><hr><ol><li>可以独立完成的动作(主语＋不及物动词)<br>Papa Rabbit <strong>sleeps.</strong></li><li>有一个承受者(主语+单及物动词+宾语)<br>Papa Rabbit <strong>likes</strong> <em>you.</em></li><li>有两个动作承受者(主语+双及物动词+间接宾语+直接宾语)<br>Papa Rabbit <strong>teaches</strong> <em>you</em> <em>English.</em></li><li>有一个动作承受者但需补充(主语+复杂及物动词+宾语+宾语补语)<br>Papa Rabbit <strong>considers</strong> <em>you</em> <del>smart.</del></li><li>非动作(主语+系动词+表语)<br>Papa <strong>is&#x2F;looks</strong> tall</li></ol><hr><h1 id="句子成分-Elements"><a href="#句子成分-Elements" class="headerlink" title="句子成分 Elements"></a>句子成分 Elements</h1><p>同一句子成分可能有不同的词类</p><p><strong>复合句</strong>&#x2F;并列句Compound Sentence:句子叠加,并列关系</p><p><strong>复杂句</strong>Complex Sentence:一个句子套一个句子,或者继续套下去…,从属关系</p><table><thead><tr><th>作主语</th><th>作宾语</th><th>作表语</th><th>作同位语</th></tr></thead><tbody><tr><td>主语从句</td><td>宾语从句</td><td>表语从句</td><td>同位语从句</td></tr></tbody></table><blockquote><p>以上为名词性从句,具有名词性质</p></blockquote><table><thead><tr><th>作定语</th><th>作状语</th></tr></thead><tbody><tr><td>定语从句</td><td>状语从句</td></tr></tbody></table><hr><ol><li>主语</li><li>谓语</li><li>宾语</li><li>宾语补足语</li><li>主语补足语(表语)</li><li>定语,主要修饰主语或宾语<br><strong>The little white</strong> rabbit ate <strong>a large</strong> carrot</li><li>状语,主要修饰谓语动词<br>The rabbit ate <strong>quickly</strong></li><li>同位语,再把主语或宾语描述一遍<br>PaPa Rabbit, <strong>an English teacher</strong>,eats carrots.</li></ol><hr><h1 id="词性Parts-of-Speech"><a href="#词性Parts-of-Speech" class="headerlink" title="词性Parts of Speech"></a>词性Parts of Speech</h1><ol><li><p>名词 nouns,表人和物</p></li><li><p>冠词 articles,说明人和事物<br><strong>a</strong> rabbit.</p></li><li><p>代词 pronouns,代替人和物<br><strong>I</strong> am a rabbit.</p></li><li><p>形容词adjectives,形容人和物<br>I am a <strong>smart</strong> rabbit.</p></li><li><p>数词 numerals,表示数量<br>I ate <strong>two</strong> carrots.</p></li><li><p>副词 adverbs,修饰动词或形容词<br>I ate two carrots <strong>quickly</strong>.</p></li><li><p>介词 prepositions,表示和其他词关系的词<br>I ate two carrots <strong>with</strong> chopsticks.</p></li><li><p>叹词 interjections,表示感叹<br><strong>Ah</strong>,the carrots is tasty.</p></li><li><p>连词 conjunctions,连接词与句<br>I ate two carrots and a photo,<strong>because</strong> I was hungry.</p></li><li><p>动词 verb,往往不能独立完成<strong>TAM</strong>,否定&#x2F;可能&#x2F;必须等需要<strong>助动词</strong></p><blockquote><p>时<strong>T</strong>ense时间<br>体<strong>A</strong>spect动作状态<br>气<strong>M</strong>ood动作假设,情感</p></blockquote></li></ol><table><thead><tr><th></th><th>一般</th><th>进行</th><th>完成</th><th>完成进行</th></tr></thead><tbody><tr><td><strong>现在</strong></td><td>一般现在时态</td><td>现在进行时态</td><td>现在完成时态</td><td>现在完成进行时态</td></tr><tr><td></td><td>eat&#x2F;eats</td><td>am&#x2F;is&#x2F;are eating</td><td>has&#x2F;have eaten</td><td>has&#x2F;have been eating</td></tr><tr><td><strong>过去</strong></td><td>一般过去时态</td><td>过去进行时态</td><td>过去完成时态</td><td>过去完成进行时态</td></tr><tr><td></td><td>ate</td><td>was&#x2F;were eating</td><td>had eaten</td><td>had been eating</td></tr><tr><td><strong>将来</strong></td><td>一般将来时态</td><td>将来进行时态</td><td>将来完成时态</td><td>将来完成进行时态</td></tr><tr><td></td><td>will eat</td><td>will be eating</td><td>will have eaten</td><td>will have been eating</td></tr><tr><td><strong>过去将来</strong></td><td>一般过去将来时态</td><td>过去将来进行时态</td><td>过去将来完成时态</td><td>过去将来完成进行时态</td></tr><tr><td></td><td>would eat</td><td>would be eating</td><td>would have eaten</td><td>would have been eating</td></tr></tbody></table><blockquote><p><strong>时间</strong>与<strong>动作状态</strong>可以进行组合</p></blockquote><h2 id="非谓语动词"><a href="#非谓语动词" class="headerlink" title="非谓语动词"></a>非谓语动词</h2><p>动词可能被用作主谓宾定状补,称为非谓语动词.几乎可取代所有从句,却不再具有标识TAM的能力.</p>]]></content>
      
      
      <categories>
          
          <category> NOTE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高考</title>
      <link href="/2024/07/10/%E9%AB%98%E8%80%83/"/>
      <url>/2024/07/10/%E9%AB%98%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p><img src="http://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E9%AB%98%E8%80%83/%E9%AB%98%E8%80%83.jpg"></p><h2 id="高考前的日子-📚"><a href="#高考前的日子-📚" class="headerlink" title="高考前的日子 📚"></a>高考前的日子 📚</h2><p>现在是高考完后的一个月多三天。回忆起高考前的高三生活，大部分都已经模糊不清。也许是考后的网络冲浪和种种放纵冲淡了这些记忆，心中居然会有些怀念。（不可能想回去哈哈）</p><p>像高考语文中那句“往事总在回忆时被赋予意义”。</p><span id="more"></span><p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E9%AB%98%E8%80%83/%E8%8A%B1%E6%9C%B5.jpg"></p><blockquote><p>瓜哥插的花</p></blockquote><p>高三下的日子充满了压力，尤其在最后两个月。各种摆烂的想法和斗志满满的心态不断在脑中交替循环。我常常为以前荒芜的学习时间感到懊悔与无奈，同时不断提醒自己知来者可追的道理。</p><p>矛盾的心理在我心中上演。面对无数份试题，我常常在紧要关头懈怠，但好在身边的朋友和同学总能帮助我渡过这些崩溃时刻。我再也不愿体验那种看到那400出头的分数的心情。好在高考前，我的心态有所好转，心态的转变对我的高考尤为重要。</p><p>高三也是多病多灾的时期。在这一年，我崴了脚，屁股上还做了个贼痛的手术，最后一个月几乎被神经头痛所包围，直到考前我的头仍然再痛。</p><p>高中整个阶段虽然乏味，但它难得地给了我许多空闲时间去想象和思考，而不是被手机通知打扰。这一点我非常想念。</p><h2 id="仓促的成人礼-🎓"><a href="#仓促的成人礼-🎓" class="headerlink" title="仓促的成人礼 🎓"></a>仓促的成人礼 🎓</h2><p><img src="http://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E9%AB%98%E8%80%83/%E7%8E%8B%E8%80%81%E5%B8%88%E5%90%88%E5%BD%B1.jpg"></p><blockquote><p>和王哥合影</p></blockquote><p>成人礼是高考前最重要的活动。每个人都准备好写给父母的信，并把写满理想愿望的卡片挂在树枝上。领导在台上的演讲一如既往地无聊。</p><p>结束演讲后，我们都越过一道门，与老师击掌。牛嗲甚至握住了我的手，这点值得一提，因为我的物理选择题啥也不会做也有48分。</p><p>那天下起了小雨，仪式只用了一个上午的时间，三年的高中生活以这种方式结束，我并没有准备好迎接高考。</p><h2 id="参加高考-📝"><a href="#参加高考-📝" class="headerlink" title="参加高考 📝"></a>参加高考 📝</h2><p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E9%AB%98%E8%80%83/%E6%94%B6%E4%B9%A6.jpg"></p><blockquote><p>收书，不要的扔掉，结果全部扔掉了</p></blockquote><p>坐上大巴，高一和高二的同学们像往年一样为高三的我们加油送行。</p><p>我的心情早已在这种氛围中归于佛系。值得一提的是考前的前一个晚上，学校用车灯照亮了我们回寝的路，这点九中值得表扬。</p><p>我带上了平时需要的东西，其中我最爱的喜多多也没落下。尽管它很沉，但它早已融入了我的校园生活，有了它，我会多一分安心少一分不安。</p><p>铺好床，熟悉考场，听老师强调重点注意事项。我的内心平静，放下了以往的焦虑，有种接受审判的从容。</p><p>考前那一个晚上，意料之中地我没有睡着。我穿着拖鞋考完了语文和数学，似乎和往常一样，只是做得题目多了一些而已。直到最后一门科目生物考完，高考也就结束了。</p><p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E9%AB%98%E8%80%83/%E8%B5%B0%E5%BB%8A.jpg"></p><blockquote><p>宿舍走廊</p></blockquote><h2 id="考后-🎉"><a href="#考后-🎉" class="headerlink" title="考后 🎉"></a>考后 🎉</h2><p>坐上了回程的大巴车，手机上已经能搜到答案。瞄了一眼，似乎错的还挺多，就没再看了。关掉手机，心中莫名难受，但很快车就到校了，我马上恢复到了亢奋的状态，因为我期盼已久的假期此时正在眼前。</p><p>我去了北京，打卡了各处我曾心心念念的景点。加上手机信息的轰炸，我的情绪早已被磨平，很难有大起大落。</p><p>在成绩出来的那一天，先去和朋友看了云边，然后买了一杯奶茶，回到家里打开电脑查看成绩。尽管结果不是很高，但超出了我的预期。至少也有书读了，是吧？我不知道这一切是好是坏，但确实是一个月前我所期盼的结果。</p><p>成绩出来后，我没有喝酒也没有疯玩，只是平静地接受了一切，为我的高中生活划上了句号。</p>]]></content>
      
      
      <categories>
          
          <category> 最近的事~ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次引流手术</title>
      <link href="/2024/02/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%BC%95%E6%B5%81%E6%89%8B%E6%9C%AF/"/>
      <url>/2024/02/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%BC%95%E6%B5%81%E6%89%8B%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="https://yublog-image.oss-cn-shenzhen.aliyuncs.com/image/2024/%E5%BC%95%E6%B5%81%E6%89%8B%E6%9C%AF/shoushu.jpg"></p><blockquote><p>行刑地</p></blockquote><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>今年我做了人生中的第一个小手术，引流手术。如果你看到“火疖子”“囊肿”这几个词在幸灾乐祸，你最好保佑好自己🙏不会有这些东西。</p><p>伏笔大概已经在去年就埋好了，那时候在学校因为坐得久，屁股上长了一个小肿块，是的，一个小肿块和我的屁股和谐共生。</p><span id="more"></span><h1 id="生长"><a href="#生长" class="headerlink" title="生长"></a>生长</h1><p>过年我把这件事和家里人说了，他们推荐我擦点药，我照做了，并逐渐对这个肿块产生了非常大的兴趣，经常没事去看看它还在不在，我现在真特么后悔那时手贱的自己啊。</p><p>我估计因为这事刺激到我们这个小可爱了，去学校后，吃的差的原因，免疫力下降，屁股那块开始就慢慢肿起来了。</p><p>开始并不大，我没当回事，知道我发现我淋巴开始肿起来了才意识到问题的严重。</p><p>等有鸽子蛋🥚那么大的时候，坐在椅子上就是煎熬了，因为上学要一直坐那，我真的想die。过了一天，是最痛的时候，有一个鸡蛋那么大了。</p><p>怎么描述那种感觉了？每次坐下去和起来，我都要倍受2分钟的折磨，肌肉全部缩紧，痛的我冷汗出来。还好终于熬到放假了🙂。</p><h1 id="手术"><a href="#手术" class="headerlink" title="手术"></a>手术</h1><p>看病的时候，给我问诊的医生是一个的大姐姐，在看过我病情后说，这么严重了，只能引流了。只是一句“有点痛”迷惑了一波我。</p><p>到此为止，我还以为问题不是很严重。</p><p>动刀子的房间两个男医生一个女医生，他们只是让我准备一下。我笑嘻嘻的躺上去以为马上就能结束痛苦。</p><p>开始消毒，打麻药，卧槽直接叫出来，这他马是有点痛？那针好像好粗一根，结果后面感受还是很痛。当开始引流的时候，我手直接抓死了床单，脑子只有我草能说出来根本想不出别的词。</p><p>不过这里的医生挺有味，说要出一篇论文研究下人在疼痛的情况下会叫什么🙂，他们说我的言语虽然激烈了一些，但是身体却没有乱动，已经很棒了。我一直喘大气，直到弄完。我力气都没了，虚脱了，感觉嘴巴都白掉了。</p><p>差点痛出这个美丽世界。</p><h1 id="换药"><a href="#换药" class="headerlink" title="换药"></a>换药</h1><p>我以为我已经熬完了这场浩劫。第二天开开心心去换药以为只是消个毒。</p><p>特么没想到，痛感还是那么大，只是持续时间少了点，这次我只说了一声😯🌿然后哼哼哼的扛了过去，听说是要把消毒棉花塞进去，还要换几次药😭哎。</p><p>今天是第二次换药，医生很好，但还是很痛，但没有那么久了。医生说我伤口还有炎症，并且我才知道要把纱布塞进肉里面，换药时候拔出来重新塞进去一个。</p><p>形象点描述就是：每天换药就像屁股中了一枪</p>]]></content>
      
      
      <categories>
          
          <category> 最近的事~ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
            <tag> 生病 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于写日记</title>
      <link href="/2024/02/08/%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/02/08/%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要写日记❔️"><a href="#为什么要写日记❔️" class="headerlink" title="为什么要写日记❔️"></a>为什么要写日记❔️</h1><p>写日记可以回顾记忆、理解自我思想、改变对待生活的态度。日记是理解自己想法和感受的方式，可以通过问自己问题来审问自己。写日记的三个方式分别是记录当天事情、讲故事和写晨报。通过写日记，可以增加对生活的欣赏和创造力。总结自Ali Abdaal</p><span id="more"></span><h1 id="晨间日记🥪"><a href="#晨间日记🥪" class="headerlink" title="晨间日记🥪"></a>晨间日记🥪</h1><p>想到什么就写一些什么，开阔一下自己的想象力。如果实在是不知道从何处起笔，那么可以这样子写，现在是2月8日的下午，我坐在床上…</p><h1 id="心情日记😀"><a href="#心情日记😀" class="headerlink" title="心情日记😀"></a>心情日记😀</h1><p>纪录今天做了什么事情？今天发生的几件事？重点落在思绪，感受，情感……</p><p>表达性写作，纪录生活中任何痛苦，消极，抓马的事，主要记录今天自己的感受（情绪），以及对事情的想法，并反思今天的行为如何影响自己的心情，可以如何更积极应对。</p><h1 id="日记作业📘"><a href="#日记作业📘" class="headerlink" title="日记作业📘"></a>日记作业📘</h1><p>今天发生在我身上的最有故事价值的事情是什么？</p><h1 id="感恩日记❤"><a href="#感恩日记❤" class="headerlink" title="感恩日记❤"></a>感恩日记❤</h1><p>所感激的人或事（关注自己生活中发生的美好的事情上）<br>你感激的三件事是什么，我很感谢谁，描述这个人的特点的三个品质，此人在什么时候展现出了这些品质。</p><h1 id="决策日记🤔"><a href="#决策日记🤔" class="headerlink" title="决策日记🤔"></a>决策日记🤔</h1><p>1、思考：<br>（1）你应该做什么？<br>（2）你想做什么决定？<br>（3）此时此地你应该采取什么行动？</p><p>以上为内容复制来的</p>]]></content>
      
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇</title>
      <link href="/2024/02/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
      <url>/2024/02/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="终于"><a href="#终于" class="headerlink" title="终于"></a>终于</h1><p>折腾了几天，断断续续的终于配置好了我的博客，就让这一篇成为开始吧。应该我能保持一个月至少更新一次吧，此站域名长期不会变化。</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 最近的事~ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/09/hello-world/"/>
      <url>/2023/09/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
